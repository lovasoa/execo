#!/usr/bin/env python
# -*- coding: utf-8 -*-
#	
#	Funk: (F)ind (U)r (N)odes on G5(K)
# 	Created by L. Pouilloux and M. Imbert (INRIA, 2013)
#
import sys, pprint as PP, time as T, datetime as DT, logging
import execo as EX, execo.time_utils as ET, execo_g5k as EX5, execo_g5k.api_utils as API
from optparse import OptionParser, OptionGroup
from execo.log import set_style
from execo_g5k.config import g5k_configuration
from execo_g5k.oar import format_oar_date, format_oar_duration
from execo_g5k.oargrid import get_oargridsub_commandline
from execo import logger
try:
	import matplotlib as MPL
	import matplotlib.dates as MD
	from matplotlib import pylab as PLT
	
	
	with_mpl = True
except ImportError:
	with_mpl = False


class funk(object):
	'''
	This tool determine when the resources you need are available on Grid5000 
	platform thanks to the analysis of Gantt diagram obtained form API   
	and can (optionally) make the oargrid reservation.
	
	It has two modes:
	- find the slots for a combination of resources 	(free_slots)
	- find the maximum number of nodes 					(max_nodes)
	for the period specified.
	
	Parameters:
	
	mode		= 'free_slots' or 'max_nodes'
	walltime  	= duration of your reservation
	resources	= dict containing the number of nodes for a grid5000 element (grid5000, site, cluster). 
		if mode is 'max_nodes', the number represent the minimum number of nodes you want for this element.
	vlan		= a string of the form slash_22=1
	kavlan		= a boolean that allow you to have a kavlan
	weeks 		= the number of weeks to look in  
	auto 		= 'freeslots' choose the first slot that fits your need
				  'max_nodes' choose the slots where you have the maximum number of nodes 
				  and perform the reservation 
	with_plots	= a boolean to specify if you want to see the gantt diagram for your resources 
				(require Matplotlib)
	log			= a boolean to specify that you want the execution log
	
	Require execo 2.1, http://execo.gforge.inria.fr/doc/
	'''
	def __init__(self, mode, walltime, resources, vlan = None, kavlan = None, 
				weeks = 1, auto = False, with_plots = False, oargridsub_opts = None):
		''' Creating the required variable used by funk'''
		logger.info('%s', set_style('INITIALIZATION\n', 'object_repr'))
		self.set_resources(mode, resources, vlan, kavlan)
		self.set_times(walltime, weeks)
		self.set_execution(auto, with_plots, oargridsub_opts)
		
		
	def set_colors(self):
		self.colors = {} 
		rgb_colors = [(x[0]/255., x[1]/255., x[2]/255.) for x in \
					[(255., 122., 122.), (255., 204., 122.), (255., 255., 122.), (255., 246., 153.), (204., 255., 122.), 
					(122., 255., 122.), (122., 255., 255.), (122., 204., 255.), (204., 188., 255.), (255., 188., 255.)]]
		i_site = 0
		for site in sorted(API.get_g5k_sites()):
			self.colors[site] = rgb_colors[i_site]
			i_cluster = 0
			for cluster in sorted(API.get_site_clusters(site)):
				min_index = self.colors[site].index(min(self.colors[site]))
				color = [0., 0., 0.]
				for i in range(3):
					color[i] = min(self.colors[site][i], 1.)
					if i == min_index:
						color[i] += i_cluster * 0.1
				self.colors[cluster] = tuple(color)
				i_cluster += 1
			i_site += 1
		
		
		
	def set_times(self, walltime, weeks):
		''' Define all the variable related in timestamp and show it to the user'''
		h, m, s = walltime.split(':')
		self.duration = ET.timedelta_to_seconds(DT.timedelta(hours=int(h), minutes=int(m), seconds=int(s)))
		self.startstamp = int(T.time()+ET.timedelta_to_seconds(DT.timedelta(seconds = 30)))
		self.endstamp = int(self.startstamp + ET.timedelta_to_seconds(DT.timedelta(weeks=weeks)))
		logger.info('Walltime: %s, between now and %s', 
				set_style(ET.format_seconds(self.duration), 'emph'),
				set_style(format_oar_date(self.endstamp), 'emph'))
		logger.info('%s', set_style('Done\n', 'object_repr'))

	def set_resources(self, mode, resources, vlan, kavlan):
		''' Define and print the resources the user request'''
		self.mode = mode
		if mode == 'free_slots':
			log = 'Finding a slot for the following resources: '
		elif mode == 'max_nodes':
			log = 'Finding the maximum number of nodes, with the following constrains: '
		else:
			logger.error('Unsupported mode %s', set_style(mode, 'report_error'))
			exit()	
		logger.info('%s', log)
		self.resources = {}
		
		for resource, n_nodes in resources.iteritems():
			log =''+('- '+set_style(resource, 'emph')+' ').ljust(30-len(str(n_nodes)))\
				+str(n_nodes)+' nodes'
			logger.info('%s', log)
			self.resources[resource] = n_nodes
		if self.resources.has_key('grid5000.fr'):
			for site in API.get_g5k_sites():
				self.resources[site] = resources[site] if resources.has_key(site) else 0
			for cluster in API.get_g5k_clusters():
				self.resources[cluster] = resources[cluster] if resources.has_key(cluster) else 0
		
		
		self.vlan = vlan
		self.kavlan = kavlan
		
	def set_execution(self, auto, with_plots, oargridsub_opts):
		
		if with_plots and with_mpl:
			with_plots = True
		else:
			with_plots = False
			
		if auto:
			self.compute_planning()
			self.compute_slots()
			self.choose_slot( auto )
			self.make_reservation( oargridsub_opts = oargridsub_opts, auto = auto )
		else:
			self.with_plots = with_plots
		

	def compute_planning(self):
		logger.info('%s',set_style('GETTING PLANNINGS FROM API', 'object_repr'))
		self.planning = {}
		
		if self.resources.has_key('grid5000.fr'):
			logger.info('for the %s', set_style('whole platform \n', 'emph'))
			self.planning = self.grid5000_planning(self.startstamp, self.endstamp)
		else:
			for resource in self.resources:
				if resource in API.get_g5k_sites():
					log = 'for site '+ set_style(resource, 'emph')
					self.planning[resource] = self.site_planning(resource, self.startstamp, self.endstamp)
				else:
					log = 'for cluster '+ set_style(resource, 'emph')
					site = API.get_cluster_site(resource)
					if not self.planning.has_key(site):
						self.planning[site] = {}
					self.planning[site][resource] = self.cluster_planning(resource, self.startstamp, self.endstamp)
				logger.info('%s', log)
		
		logger.info('%s', set_style('Done\n', 'object_repr'))

	def host_planning(self, host_reservations, startstamp, endstamp):
		''' Compute the planning from the dict of reservations gathered from the API'''
		planning = {'busy': [], 'free': []}
		for job in host_reservations:
			if job['queue']!='besteffort' and (job['start_time'],job['start_time']+job['walltime']) not in planning['busy']:
				job['start_time'] = max(job['start_time'], startstamp)
				planning['busy'].append( (job['start_time'], job['start_time']+job['walltime']+61) )
		planning['busy'].sort()
		if len(planning['busy']) > 0:
			if planning['busy'][0][0] > startstamp:
				planning['free'].append((startstamp, planning['busy'][0][0])) 
			for i in range(0, len(planning['busy'])-1):
				planning['free'].append((planning['busy'][i][1], planning['busy'][i+1][0]))
			if planning['busy'][len(planning['busy'])-1][1]<endstamp:
				planning['free'].append((planning['busy'][len(planning['busy'])-1][1], endstamp))
		else:
			planning['free'].append((startstamp, endstamp))
		return planning	
		
	def cluster_planning(self, cluster, startstamp, endstamp):
		''' Return a dict containing all alive nodes and their planning for a given cluster'''
		cluster_planning = {}
		site = API.get_cluster_site(cluster)
		hosts = API.get_resource_attributes('/grid5000/sites/'+site+'/clusters/'+cluster+'/status?reservations_limit=100')
		for host in hosts['items']:
			if host['hardware_state'] != 'dead':
				cluster_planning[host['node_uid']] = self.host_planning(host['reservations'], startstamp, endstamp)
		return cluster_planning
		
				
	def site_planning(self, site, startstamp, endstamp):
		''' Return a dict containing all alive nodes and their planning for a given site'''
		site_planning = {}
		hosts = API.get_resource_attributes('/grid5000/sites/'+site+'/status?reservations_limit=100')
		for host in hosts['items']:
			cluster = API.get_host_cluster(host['node_uid'])
			if not site_planning.has_key(cluster):
				site_planning[cluster] = {}
			if host['hardware_state'] != 'dead':
				site_planning[cluster][host['node_uid']] = self.host_planning(host['reservations'], startstamp, endstamp)
		return site_planning
		
	def grid5000_planning(self, startstamp, endstamp):
		''' Return a dict containing all alive nodes and their planning for a the whole platform'''
		grid_planning = {}
		sites = API.get_g5k_sites()
		for site in sites:
			grid_planning[site] = self.site_planning(site, startstamp, endstamp)	
		return grid_planning
	
	def slots_limits(self):
		self.limits = []
		
		for clusters  in self.planning.values():
			for hosts in clusters.values():
				for planning in hosts.itervalues():
					for limits in planning['busy']:
						if limits[0] not in self.limits and limits[0] >= self.startstamp \
							and limits[0] < self.endstamp:
							self.limits.append(limits[0])
						if limits[1] not in self.limits and limits[1] >= self.startstamp \
							and limits[1] < self.endstamp:
							self.limits.append(limits[1])
					for limits in planning['free']:
						if limits[0] not in self.limits and limits[0] >= self.startstamp \
							and limits[0] < self.endstamp:
							self.limits.append(limits[0])
						if limits[1] not in self.limits and limits[1] >= self.startstamp \
							and limits[1] < self.endstamp:
							self.limits.append(limits[1])
		if self.endstamp not in self.limits:
			self.limits.append(self.endstamp)			
		self.limits.sort()
		
		
	def merge_slots(self, slots):
		
		if len(slots)>1:
			list_slots = list(enumerate(sorted(slots.iteritems())))
			for i in range(len(slots)):
				j = i+1
				if j == len(list_slots)-1:
					break
				while True:
					if list_slots[i][1][0][1] == list_slots[j][1][0][0] \
						and list_slots[i][1][1] == list_slots[j][1][1]:
						list_slots[i] = (i, ((list_slots[i][1][0][0], list_slots[j][1][0][1]), list_slots[i][1][1]))
						list_slots.pop(j)
						if j == len(list_slots)-1:
							break	
					else:
						break
				if j == len(list_slots)-1:
					break
			slots.clear()
			for slot in list_slots:
				slots[(slot[1][0][0], slot[1][0][1])] = slot[1][1] 			
			
		
	
		
	def compute_slots(self):
		''' Determine all the slots limits and find the number of available nodes for each resources'''
		logger.info('%s', set_style('COMPUTING SLOTS', 'object_repr'))
		slots = {}
		self.slots_limits()
		
		for i in range(len(self.limits)-1):
			slot_limit = (self.limits[i], self.limits[i+1])
			slots[slot_limit] = {}
			for site, clusters  in self.planning.iteritems(): 
				slots[slot_limit][site] = 0
				for cluster, hosts in clusters.iteritems():
					slots[slot_limit][cluster] = 0
					for host in hosts.itervalues():
						for slot in host['free']:
							if self.limits[i] >= slot[0] and self.limits[i] + self.duration <= slot[1]:
								slots[slot_limit][cluster] += 1						
					slots[slot_limit][site] += slots[slot_limit][cluster]
		
		
		self.merge_slots(slots)
			
		g5k_clusters = API.get_g5k_clusters()
		for limit, elements in iter(sorted(slots.iteritems())):			
			slots[limit]['TOTAL'] = 0 
			for element, n_nodes in elements.iteritems():
				if element in g5k_clusters:
					slots[limit]['TOTAL'] += n_nodes
			
		self.slots = slots
		
		self.find_slot()
		
		logger.info('%s', set_style('Done\n', 'object_repr'))
		
	def find_slot(self):
		if self.mode == 'free_slots':
			logger.info('Filtering slots with enough resources')
			slots_ok = {}
			for slot, resource in self.slots.iteritems():
				slot_ok = True
				if slot[1]- slot[0] >= self.duration:
					for element, n_nodes in self.resources.iteritems():
						if element == 'grid5000.fr':
							element = 'TOTAL'
						if resource[element] < n_nodes:
							slot_ok = False
				else:
					slot_ok = False
				if slot_ok:
					slots_ok[slot] = resource
			self.slots_ok = slots_ok
		else:
			logger.info('Choosing slot with max nodes')
			max_slot = {}
			max = 0
			for slot, resource in iter(sorted(self.slots.iteritems())):
					if resource['TOTAL'] > max:
						max = resource['TOTAL']
						max_slot = { slot : resource}
			self.max_slot = max_slot
		
	def choose_slot(self, auto = False):
		logger.info('%s',set_style('CHOOSING SLOT', 'object_repr'))
		if self.mode == 'max_nodes':
			log = 'Max number of nodes is available for slot:'
			slots = self.max_slot
			self.chosen_slot =  self.max_slot.keys()[0][0]
			for element, n_nodes in self.max_slot.values()[0].iteritems():
				if self.resources.has_key(element):
					self.resources[element] = n_nodes
			
		elif self.mode == 'free_slots':
			log = 'Select the slot you want:'
			slots = self.slots_ok
			
	
		if len(slots) == 0:
			logger.error('There is not enough resources for your parameters, aborting ...')
			exit()
		if auto:
			log = 'Selecting automatically the slot:'
			self.chosen_slot = DT.datetime.fromtimestamp(sorted(slots.iteritems())[0][0][0])		
		else:
			slot_log = ''
			i_slot = 0
			for slot, resource in iter(sorted(slots.iteritems())):
				slot_log += '\n'+set_style(i_slot, 'report_error')+' - '+set_style(format_oar_date(slot[0]), 'report_warn')+'\n'
				for element, n_nodes in resource.iteritems(): 
					if self.resources.has_key(element):
						slot_log += set_style(element, 'emph')+': '+ str(n_nodes)+' '
				i_slot += 1
			logger.info('%s', log+slot_log)
			
			if not auto and self.mode != 'max_nodes':
				i_slot = raw_input('Give slot number or (x) to exit: ')
				if i_slot == 'x':
					exit()
				i_slot = int(i_slot)
				self.chosen_slot = DT.datetime.fromtimestamp(sorted(slots.iteritems())[i_slot][0][0])
		
		
			
	
	def make_reservation(self, oargridsub_opts = None, auto = None):
		
		sites = []
		g5k_sites = API.get_g5k_sites()
		g5k_clusters = API.get_g5k_clusters()
		if self.resources.has_key('grid5000.fr'):
			sites = g5k_sites
		else:
			for element in self.resources.iterkeys():
				if element in g5k_sites:
					site = element
				elif element in g5k_clusters:
					site = API.get_cluster_site(element)
				if site not in sites:
					sites.append(site)
		
		subs = []
		getkavlan = False
		if self.kavlan is not None:
			getkavlan = True
		
		if self.resources.has_key('grid5000.fr'):
			logger.info('Determining which sites to use for your reservation')
			total_nodes=0
			sites_nodes={}
			for site in sites:
				if self.resources.has_key(site):
					sites_nodes[site]=self.resources[site]
				else:
					sites_nodes[site]=0
			while total_nodes != self.resources['grid5000.fr']:
				max_site = ''
				max_nodes = 0
				for site in sites:
					hosts = self.get_hosts_element(site)
					host_available=0
					start = int(T.mktime(self.chosen_slot.timetuple()))
					if start+self.duration <self.enddate_stamp:
						stop = start+self.duration 
					else:
						stop = self.enddate_stamp
					for slots in hosts.itervalues():
						for freeslot in slots['free']:
							if start>=freeslot[0] and stop<=freeslot[1]:
								host_available+=1
					if max_nodes<host_available-sites_nodes[site]:
						max_site=site
						max_nodes=host_available-sites_nodes[site]
				sites_nodes[max_site]+=1
				total_nodes+=1
			self.resources.clear()
			for site, n_nodes in sites_nodes.iteritems():
				if n_nodes>0:
					self.resources[site]=n_nodes

		for site in sites:
			sub_resources=''
			cluster_nodes=0
			
			if getkavlan:
				sub_resources="{type=\\'kavlan-global\\'}/vlan=1+"
				getkavlan = False
				
			if self.vlan is not None:
				sub_resources+=self.vlan+'+'
			
			for cluster in API.get_site_clusters(site):
				
				if cluster in self.resources:
					sub_resources += "{cluster=\\'"+cluster+"\\'}/nodes="+str(self.resources[cluster])+'+'
					cluster_nodes += self.resources[cluster]
					if site not in self.resources:
						self.resources[site] = self.resources[cluster]
					else:
						self.resources[site] += self.resources[cluster]
				
			if site in self.resources:
				sub_resources += "nodes="+str(self.resources[site]-cluster_nodes)+'+'
				subs.append((EX5.OarSubmission(resources=sub_resources[:-1]),site))
		
		
		walltime = format_oar_duration(self.duration)
		logger.info('Reservation command: \n\033[1m%s\033[0m',
				get_oargridsub_commandline(subs, walltime = walltime, 
					additional_options = oargridsub_opts, reservation_date = self.chosen_slot))
		
		if auto:			
			(self.oargrid_job_id, self.ssh_key) = EX5.oargridsub(subs, walltime=walltime, additional_options=oargridsub_opts,reservation_date=self.chosen_slot)
			logger.info('Grid reservation done, oargridjob_id = %s', self.oargrid_job_id)
		else:			
			reservation=raw_input('Do you want me to do the reservation (y/n): ')
			if reservation=='y':
				(self.oargrid_job_id, self.ssh_key)=EX5.oargridsub(subs,walltime=walltime,additional_options=oargridsub_opts,reservation_date=self.chosen_slot)	
				logger.info('Grid reservation done, oargridjob_id = %s',self.oargrid_job_id)
	
		
	def get_hosts_element(self,element):
		element_hosts={}
		if element=='grid5000.fr':
			for site, clusters in self.hosts_plannings.iteritems():
				for hosts in clusters.itervalues():
					for host, planning in hosts.iteritems():
						element_hosts[host] = planning
		elif element in API.get_g5k_sites():
			for hosts in self.planning[element].itervalues():
				for host, planning in hosts.iteritems():
					element_hosts[host] = planning
		else:
			site = API.get_cluster_site(element)
			for host, planning in self.planning[site][element].iteritems():
				element_hosts[host] = planning
			
		return element_hosts
		
#	def draw_gantt(self):
#		''' Draw the hosts planning'''
#		self.set_colors()
#		
#		PLT.Figure(figsize=(20,15),dpi=300)
#		PLT.title('Gantt diagram for the resources you ask')
#		
#		n_res=len(self.resources) 
#		ax_all = PLT.subplot2grid((2,n_res), (1,0), colspan=n_res)
#		ax_all.set_xlim(self.startstamp, self.endstamp)
#		ax_all.set_ylim(0, n_res+1)
##		ax_all.xaxis.set_major_formatter( MD.DateFormatter('%d') )
##		ax_all.xaxis.set_major_locator(MPL.ticker.MaxNLocator(5))
##		xlabels = ax_all.get_xticklabels()
##		for label in xlabels:
##			label.set_rotation(15)
#
#		
#		i_res=0
#		for res_id, n_nodes in  self.resources.iteritems():
#			hosts=self.get_hosts_element(res_id)
#			ax = PLT.gca()
#			ax = PLT.subplot2grid((2,n_res), (0,i_res), title=res_id+': '+str(n_nodes)+'/'+str(len(hosts)))
#			ax.set_xlim(self.startstamp, self.endstamp)
#			ax.set_ylim(0, 1)
#			ax.xaxis.set_visible(False)
#			ax.yaxis.set_visible(False)
#			
#			pos=0.1
#			if len(hosts)!=0:
#				inc=0.9/len(hosts)
#			else:
#				inc=0.9
#			for slots in hosts.itervalues():					
#				for freeslot in slots['free']:
#					ax.barh(pos, (freeslot[1] -freeslot[0]), 1,
#	           			color='g', left=freeslot[0], edgecolor='none' )
#				for busyslot in slots['busy']:
#					ax.barh(pos, (busyslot[1] - busyslot[0]), 1,
#	           			color='r', left=busyslot[0], edgecolor='none' )
#				pos+=inc	
#				
#			color=(float(i_res+1)/float(n_res)/2,float(i_res+1)/float(n_res),1)
#			
#			for window, resource in self.slots.iteritems():
#				
#				if resource[res_id] >= n_nodes:
#					ax.barh(0, (window[1]-window[0]), 0.1,
#               			color=color, left=window[0], edgecolor='none' )
#					ax_all.barh(i_res+1, (window[1]-window[0]), 1,
#             			color=color, left=window[0], edgecolor='none' )
#			ax_all.text((self.endstamp+self.startstamp)/2,i_res+1.5,res_id)
#			ax_all.yaxis.set_visible(False)
#			i_res+=1	
#			
#		for window in self.slots_ok:
#			ax_all.barh(0, (window[1]-window[0]), 1,
#             		color='y', left=window[0], edgecolor='none' )
#		#PLT.savefig ('platform-'+self.restime+'.png')
#		PLT.show()

		
		
#	def draw_max_nodes(self):
#		''' Draw the maximum number of nodes available as a function of time'''
#		self.set_colors()		
#				
#		max_nodes = {}
#		total_nodes = 0
#		slot_limits = []
#		total_list = []
#		for slot, elements in iter(sorted(self.slots.iteritems())):
#			slot_limits.append(slot[0])
#			slot_limits.append(slot[1]-1)
#			for element, n_nodes in elements.iteritems():
#				if element in API.get_g5k_clusters():
#					if not max_nodes.has_key(element):
#						max_nodes[element] = []
#					max_nodes[element].append(n_nodes)
#					max_nodes[element].append(n_nodes)
#				if element == 'TOTAL':
#					total_list.append(n_nodes)
#					total_list.append(n_nodes)
#					if n_nodes > total_nodes:
#						total_nodes = n_nodes
#		slot_limits.sort()
#		dates=[ET.unixts_to_datetime(ts) for ts in slot_limits]
#		
#		datenums=MD.date2num(dates)
#		
#		fig = PLT.figure(figsize=(15,10), dpi=80)
#		PLT.title('Choose your slot')
#		ax = PLT.subplot(111)
#		ax.xaxis_date()
#		box = ax.get_position()
#		ax.set_position([box.x0-0.07, box.y0, box.width, box.height])
#		ax.set_xlim(ET.unixts_to_datetime(min(self.limits)), ET.unixts_to_datetime(max(self.limits)))
#		ax.set_xlabel('Time')
#		ax.set_ylabel('Nodes available')
#		ax.set_ylim(0, total_nodes*1.1)
#		ax.axhline(y = total_nodes, color = '#000000', linestyle ='-', linewidth = 2, label = 'ABSOLUTE MAXIMUM')
#		ax.yaxis.grid(color='gray', linestyle='dashed')
#		xfmt = MD.DateFormatter('%d %b, %H:%M')
#		ax.xaxis.set_major_formatter(xfmt)
#
#		
#		max_nodes_list = []
#		
#		p_legend = []
#		p_rects = []
#		p_colors = []
#		for key, value in iter(sorted(max_nodes.iteritems())):
#			if key != 'TOTAL':
#				max_nodes_list.append(value)
#				p_legend.append(key)
#				p_rects.append(PLT.Rectangle((0, 0), 1, 1, fc = self.colors[key]))
#				p_colors.append(self.colors[key])
#		plots = PLT.stackplot(datenums, max_nodes_list, colors = p_colors)
#		PLT.legend(p_rects, p_legend, loc='center right', ncol = 1, shadow = True, bbox_to_anchor=(1.2, 0.5))
#		
#		xlabels = ax.get_xticklabels()
#		for label in xlabels:
#			label.set_rotation(15)
#
##		def onclick(event):
##			self.x = event.xdata
##			PLT.close()
##			
##		cid = fig.canvas.mpl_connect('button_press_event', onclick)
#		PLT.show()
#		#PLT.savefig ('max_nodes.png')
##		
##		print format_oar_date(slot_limits[0])
##		print self.x
##		print format_oar_date(self.x+slot_limits[0])
		
		
		
if __name__ == '__main__':
	if len(sys.argv)>1:
		usage = "usage: %prog"
		description = '''This tool determine when the resources you need are available on Grid5000 
	platform thanks to the analysis of Gantt diagram obtained form API   
	and can (optionally) make the oargrid reservation.
										  									  		
										  									  	
										  									  
	        Two modes:            										  									  	                          
	- find the slots for a combination of resources (free_slots)                               
	- find the maximum number of nodes (max_nodes)                         
	for the period specified.
	                                 
	
	Require execo 2.1, http://execo.gforge.inria.fr/doc/
		'''
		epilog = """Examples :                    
			
		    funk.py -m free_slots -r lille:10,lyon:10,sophia:10 -w 2:00:00
		    
		    funk.py -m max_nodes -r lyon:0,sophia:0,grenoble:0 -w 10:00:00 -t 0.07
		"""
		
		parser = OptionParser(usage = usage, description = description, epilog = epilog)
	
		optinout= OptionGroup(parser, "General options", "Define mode and controls I/O.")
		optinout.add_option("-m", 
						"--mode",
		                dest = "mode", 
		                default = 'free_slots',
		                help = "Setup the mode: free_slots or max_nodes (%default)")
		optinout.add_option("-y", 
						"--yes",
		                action = "store_true", 
		                dest = "yes", 
		                default = False,
		                help = "Run without prompting user for slot selection (%default)")
		optinout.add_option("-o",
						"--oargridsub_options", 
						dest = "oargridsub_opts", 
						default = "-t deploy",	
						help = "number of nodes (%default)")
#		optinout.add_option("-p", 
#						"--plots",
#		                action="store_true", 
#		                dest="plots", 
#		                default=False,
#		                help="Draw Gantt chart before choosing freeslot")
						
		parser.add_option_group(optinout)
		
		opttime= OptionGroup(parser, "Time options", "Define options related to time")
		opttime.add_option("-t",
						"--time", 
						dest="weeks", 
						default=4,	
						help="time in weeks to explore (%default)")
		opttime.add_option("-w",
						"--walltime", 
						dest="walltime", 
						default='2:00:00',	
						help="reservation walltime (%default)")
		parser.add_option_group(opttime)
		
		
		optreservation = OptionGroup(parser, "Resource options", "Customize your grid5000 deployment and choose environment.")
		optreservation.add_option("-r",
						"--resources", 
						dest="resources", 
						default='suno:2,griffon:2,sol:2,chimint:2',
						help="comma separated list of 'element1:n_nodes1,element2:n_nodes2', element can be a cluster, site or grid5000.fr")
		optreservation.add_option("-l",
						"--vlan", 
						dest="vlan", 
						default=None,	
						help="Ask for a vlan (%default)")
		optreservation.add_option("-k",
						"--kavlan", 
						dest="kavlan", 
						default=None,	
						help="Ask for a Global vlan (%default)")
		
		parser.add_option_group(optreservation)
	
		
		(options, args) = parser.parse_args()

		resources = {}
		elements = options.resources.split(',')
		
		for element in elements:
			element_uid, n_nodes = element.split(':')
			resources[element_uid]=int(n_nodes)
		
		logger = logging.getLogger('execo.funk')
		logger.setLevel(logging.INFO)
		
		run = funk(mode = options.mode, walltime = options.walltime, resources = resources, weeks = float(options.weeks),
			oargridsub_opts = options.oargridsub_opts, vlan = options.vlan, kavlan = options.kavlan, auto = options.yes)
		
		run.compute_planning()
		run.compute_slots()
		run.choose_slot()
		run.make_reservation()
				
	else:
		''' Perform a demo'''
		
		
		mode = 'free_slots'
		walltime = '8:00:00'
		#resources = {'grid5000': 100 }#, 'lille':50, 'griffon': 10}
		resources = {'toulouse': 0, 'lyon': 0, 'bordeaux': 0, 'chimint': 0}
		resources = {'taurus': 10, 'hercule': 4, 'orion': 4, 'chimint': 10}
		#resources = {'taurus': 0, 'chimint': 0, 'griffon': 0, 'edel': 0 }
		oargridsub_opts = '-t allow_classic_ssh'
		vlan = 'slash_22=1'
		
		run = funk(mode, walltime, resources, weeks = 1, vlan = vlan, kavlan = True)
		
		run.compute_planning()
		run.compute_slots()
		run.choose_slot()
		run.make_reservation(oargridsub_opts, auto = False)

	
